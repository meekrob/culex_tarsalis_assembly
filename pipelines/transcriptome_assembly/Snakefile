import os

configfile: "config/config.yaml"
ta_config = config["transcriptome_assembly"]
slurm_config = config["slurm"]["transcriptome"]

# Get the raw reads directory from config
raw_reads_dir = config["transcriptome_assembly"]["raw_reads_dir"]

rule trim_reads:
    input:
        r1 = lambda wildcards: os.path.join(raw_reads_dir, f"{wildcards.sample}_R1_001.fastq.gz") if os.path.exists(os.path.join(raw_reads_dir, f"{wildcards.sample}_R1_001.fastq.gz")) else os.path.join(raw_reads_dir, f"{wildcards.sample}_R1.fastq.gz"),
        r2 = lambda wildcards: os.path.join(raw_reads_dir, f"{wildcards.sample}_R2_001.fastq.gz") if os.path.exists(os.path.join(raw_reads_dir, f"{wildcards.sample}_R2_001.fastq.gz")) else os.path.join(raw_reads_dir, f"{wildcards.sample}_R2.fastq.gz")
    output:
        r1 = "results/transcriptome_assembly/01_trimmed/{sample}_R1_trimmed.fastq.gz",
        r2 = "results/transcriptome_assembly/01_trimmed/{sample}_R2_trimmed.fastq.gz",
        html = "results/transcriptome_assembly/01_trimmed/reports/{sample}_fastp.html",
        json = "results/transcriptome_assembly/01_trimmed/reports/{sample}_fastp.json"
    log:
        "logs/transcriptome_assembly/01_trimming/{sample}.log"
    conda:
        ta_config["conda_env"]
    resources:
        partition = slurm_config["trimming"]["partition"] if "partition" in slurm_config["trimming"] else config["slurm"]["default"]["partition"],
        time = slurm_config["trimming"]["time"],
        cpus = slurm_config["trimming"]["cpus"],
        mem = slurm_config["trimming"]["mem"]
    shell:
        """
        # Create output directories
        mkdir -p $(dirname {output.r1})
        mkdir -p $(dirname {output.html})
        
        # Run fastp with appropriate parameters (matching bin/01_trimming.sh)
        fastp \
            -i {input.r1} \
            -I {input.r2} \
            -o {output.r1} \
            -O {output.r2} \
            --html {output.html} \
            --json {output.json} \
            --detect_adapter_for_pe \
            --dedup \
            -w {resources.cpus} \
            -q 20 \
            --compression 6 \
            2> {log}
        """

rule merge_reads:
    input:
        r1 = expand("results/transcriptome_assembly/01_trimmed/{sample}_R1_trimmed.fastq.gz", sample=ta_config["samples"]),
        r2 = expand("results/transcriptome_assembly/01_trimmed/{sample}_R2_trimmed.fastq.gz", sample=ta_config["samples"])
    output:
        r1 = "results/transcriptome_assembly/02_merged/merged_reads_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/02_merged/merged_reads_R2.fastq.gz"
    log:
        "logs/transcriptome_assembly/02_merge/merge.log"
    conda:
        ta_config["conda_env"]
    resources:
        partition = slurm_config["merge"]["partition"] if "partition" in slurm_config["merge"] else config["slurm"]["default"]["partition"],
        time = slurm_config["merge"]["time"],
        cpus = slurm_config["merge"]["cpus"],
        mem = slurm_config["merge"]["mem"]
    shell:
        """
        # Create output directory
        mkdir -p $(dirname {output.r1})
        
        # Determine compression command based on available tools
        if command -v pigz >/dev/null 2>&1; then
            COMPRESS_CMD="pigz -p {resources.cpus}"
            DECOMPRESS_CMD="pigz -dc -p {resources.cpus}"
            echo "Using pigz for parallel compression/decompression" >> {log}
        else
            COMPRESS_CMD="gzip"
            DECOMPRESS_CMD="zcat"
            echo "Using standard gzip/zcat" >> {log}
        fi
        
        # Process R1 files
        echo "Processing R1 files..." >> {log}
        TEMP_FILE=$(mktemp)
        for file in {input.r1}; do
            echo "Processing $(basename $file)" >> {log}
            $DECOMPRESS_CMD "$file" >> $TEMP_FILE
        done
        $COMPRESS_CMD -1 < $TEMP_FILE > {output.r1}
        rm -f $TEMP_FILE
        
        # Process R2 files
        echo "Processing R2 files..." >> {log}
        TEMP_FILE=$(mktemp)
        for file in {input.r2}; do
            echo "Processing $(basename $file)" >> {log}
            $DECOMPRESS_CMD "$file" >> $TEMP_FILE
        done
        $COMPRESS_CMD -1 < $TEMP_FILE > {output.r2}
        rm -f $TEMP_FILE
        """

rule check_pairs:
    input:
        r1 = "results/transcriptome_assembly/02_merged/merged_reads_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/02_merged/merged_reads_R2.fastq.gz"
    output:
        r1 = "results/transcriptome_assembly/03_pairs/fixed_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/03_pairs/fixed_R2.fastq.gz"
    log:
        "logs/transcriptome_assembly/03_pairs/pair_check.log"
    conda:
        ta_config["conda_env"]
    resources:
        partition = slurm_config["pair_check"]["partition"] if "partition" in slurm_config["pair_check"] else config["slurm"]["default"]["partition"],
        time = slurm_config["pair_check"]["time"],
        cpus = slurm_config["pair_check"]["cpus"],
        mem = slurm_config["pair_check"]["mem"]
    shell:
        """
        # Create output directory
        mkdir -p $(dirname {output.r1})
        
        # Run repair.sh with appropriate parameters
        repair.sh in1={input.r1} in2={input.r2} \
            out1={output.r1} out2={output.r2} \
            overwrite=t tossbrokenreads=t repair=t \
            showspeed=t threads={resources.cpus} 2>> {log}
        """

rule normalize_bbnorm:
    input:
        r1 = "results/transcriptome_assembly/03_pairs/fixed_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/03_pairs/fixed_R2.fastq.gz"
    output:
        r1 = "results/transcriptome_assembly/04_normalized/bbnorm/norm_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/04_normalized/bbnorm/norm_R2.fastq.gz"
    log:
        "logs/transcriptome_assembly/04_normalization/bbnorm/bbnorm.log"
    conda:
        ta_config["conda_env"]
    resources:
        partition = slurm_config["bbnorm"]["partition"] if "partition" in slurm_config["bbnorm"] else config["slurm"]["default"]["partition"],
        time = slurm_config["bbnorm"]["time"],
        cpus = slurm_config["bbnorm"]["cpus"],
        mem = slurm_config["bbnorm"]["mem"]
    shell:
        """
        # Create output directory
        mkdir -p $(dirname {output.r1})
        
        # Create histogram file
        HIST_FILE=$(dirname {log})/kmer_histogram.txt
        
        bbnorm.sh in1={input.r1} in2={input.r2} \
            out1={output.r1} out2={output.r2} \
            hist=$HIST_FILE target=100 min=5 \
            threads={resources.cpus} ecc=t prefilter=t 2>> {log}
        """

rule normalize_trinity:
    input:
        r1 = "results/transcriptome_assembly/03_pairs/fixed_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/03_pairs/fixed_R2.fastq.gz"
    output:
        r1 = "results/transcriptome_assembly/04_normalized/trinity/norm_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/04_normalized/trinity/norm_R2.fastq.gz"
    log:
        "logs/transcriptome_assembly/04_normalization/trinity/trinity_norm.log"
    params:
        temp_dir = lambda wildcards: ta_config['temp_dir']
    conda:
        ta_config["trinity_env"]
    resources:
        partition = slurm_config["trinity_norm"]["partition"] if "partition" in slurm_config["trinity_norm"] else config["slurm"]["default"]["partition"],
        time = slurm_config["trinity_norm"]["time"],
        cpus = slurm_config["trinity_norm"]["cpus"],
        mem = slurm_config["trinity_norm"]["mem"]
    shell:
        """
        # Create output directory and temp directory
        mkdir -p $(dirname {output.r1})
        
        # Create temporary directory for Trinity
        TEMP_DIR="{params.temp_dir}/trinity_norm_tmp"
        mkdir -p $TEMP_DIR
        
        # Run Trinity normalization
        insilico_read_normalization.pl \
            --seqType fq \
            --JM {resources.mem}G \
            --max_cov 100 \
            --left {input.r1} \
            --right {input.r2} \
            --pairs_together \
            --PARALLEL_STATS \
            --CPU {resources.cpus} \
            --output $TEMP_DIR \
            2>> {log}
        
        # Compress the normalized files
        gzip -c $TEMP_DIR/left.norm.fq > {output.r1}
        gzip -c $TEMP_DIR/right.norm.fq > {output.r2}
        
        # Clean up temporary files
        rm -rf $TEMP_DIR
        """

rule assemble:
    input:
        r1 = "results/transcriptome_assembly/04_normalized/{norm}/norm_R1.fastq.gz",
        r2 = "results/transcriptome_assembly/04_normalized/{norm}/norm_R2.fastq.gz"
    output:
        fasta = "results/transcriptome_assembly/05_assembly/{norm}/transcripts.fasta"
    log:
        "logs/transcriptome_assembly/05_assembly/{norm}/assembly.log"
    params:
        output_dir = "results/transcriptome_assembly/05_assembly/{norm}"
    conda:
        ta_config["conda_env"]
    resources:
        partition = slurm_config["assembly"]["partition"] if "partition" in slurm_config["assembly"] else config["slurm"]["default"]["partition"],
        time = slurm_config["assembly"]["time"],
        cpus = slurm_config["assembly"]["cpus"],
        mem = slurm_config["assembly"]["mem"]
    shell:
        """
        # Create output directory
        mkdir -p {params.output_dir}
        
        # Set up temporary directory
        TMP="${{TMPDIR:-$HOME/tmp}}"
        mkdir -p $TMP
        export TMPDIR=$TMP
        
        # Calculate memory in GB (take 95% of available memory)
        MEM_GB=$(echo {resources.mem} | sed 's/G//')
        SPADES_MEM=$((MEM_GB * 95 / 100))
        
        # Run rnaSPAdes with appropriate parameters
        rnaspades.py \
            --rna \
            -1 {input.r1} \
            -2 {input.r2} \
            -o {params.output_dir} \
            -t {resources.cpus} \
            -m $SPADES_MEM \
            2>> {log}
        """

rule busco:
    input:
        "results/transcriptome_assembly/05_assembly/{norm}/transcripts.fasta"
    output:
        "results/transcriptome_assembly/06_busco/{norm}/run_diptera_odb10/short_summary.txt"
    log:
        "logs/transcriptome_assembly/06_busco/{norm}/busco.log"
    params:
        output_dir = "results/transcriptome_assembly/06_busco"
    conda:
        ta_config["conda_env"]
    resources:
        partition = slurm_config["busco"]["partition"] if "partition" in slurm_config["busco"] else config["slurm"]["default"]["partition"],
        time = slurm_config["busco"]["time"],
        cpus = slurm_config["busco"]["cpus"],
        mem = slurm_config["busco"]["mem"]
    shell:
        """
        # Create output directory
        mkdir -p {params.output_dir}
        
        # Check if input is gzipped and decompress if needed
        UNZIPPED_TRANSCRIPTOME="{input}"
        if [[ "{input}" == *.gz ]]; then
            echo "Input transcriptome is gzipped. Decompressing before BUSCO analysis..." >> {log}
            UNZIPPED_TRANSCRIPTOME=$(mktemp --suffix=.fasta)
            gunzip -c "{input}" > "$UNZIPPED_TRANSCRIPTOME"
        fi
        
        # Run BUSCO
        busco \
            -i $UNZIPPED_TRANSCRIPTOME \
            -o {wildcards.norm} \
            -l diptera_odb10 \
            -m transcriptome \
            -c {resources.cpus} \
            --out_path {params.output_dir} \
            2>> {log}
        
        # Clean up decompressed file if we created one
        if [[ "{input}" == *.gz && "$UNZIPPED_TRANSCRIPTOME" != "{input}" ]]; then
            rm -f "$UNZIPPED_TRANSCRIPTOME"
        fi
        """